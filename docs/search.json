[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This is a Quarto website.\nTo learn more about Quarto websites visit https://quarto.org/docs/websites."
  },
  {
    "objectID": "cours.html",
    "href": "cours.html",
    "title": "Cours magistraux",
    "section": "",
    "text": "Cours magistraux\n\nLe langage Julia\nCalcul en virgule flottante\nInterpolation"
  },
  {
    "objectID": "devoirs.html",
    "href": "devoirs.html",
    "title": "Pratique du calcul scientifique",
    "section": "",
    "text": "Consignes :\n\nLire les notes de cours jusqu’à la page 32.\nFaire l’exercice 2.15 et le soumettre sur Educnet.\n\nDate limite de remise : le 20 avril 2023 à 23h59."
  },
  {
    "objectID": "devoirs.html#devoir-1",
    "href": "devoirs.html#devoir-1",
    "title": "Pratique du calcul scientifique",
    "section": "",
    "text": "Consignes :\n\nLire les notes de cours jusqu’à la page 32.\nFaire l’exercice 2.15 et le soumettre sur Educnet.\n\nDate limite de remise : le 20 avril 2023 à 23h59."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Pratique du calcul scientifique",
    "section": "",
    "text": "Équipe enseignante:\n\nJean-François Barthélémy\nNoé Blassel\nShiva Darshan\nRégis Santet (la première semaine)\nRenato Spacek\nUrbain Vaes"
  },
  {
    "objectID": "liens.html",
    "href": "liens.html",
    "title": "Liens utiles",
    "section": "",
    "text": "Julia peut être installé par l’une des deux options suivantes (la seconde étant préférable car elle devrait devenir à terme la solution officielle)\n\nInstallation classique depuis le site : https://julialang.org/downloads\nInstallation par le biais de juliaup https://github.com/JuliaLang/juliaup, par exemple ici pour Windows.\nNote: sans accès au Windows Store (par exemple restrictions dues à une politique informatique d’entreprise) il est possible de trouver une solution alternative d’installation de juliaup ici qui se résume à\n\nTélécharger le fichier Julia.appinstaller\nExécuter le code suivant sous Powershell\nPS [path] Add-AppxPackage -AppInstallerFile Julia.appinstaller\n\n\n\n\n\nQuelques vidéos utiles pour se familiariser avec le langage Julia\n\nIntro to Julia tutorial (version 1.0) by Jane Herriman Introduction assez complète de la syntaxe de base et quelques éléments avancés.\nThe Unreasonable Effectiveness of Multiple Dispatch Plus de détails sur un atout majeur du langage : le “multiple dispatch”.\n\n\n\n\n\nDocumentation générale de Julia\nPlots.jl\nXsum.jl\nZygote.jl\nPolynomials.jl\nInterpolations.jl"
  },
  {
    "objectID": "liens.html#installation-de-julia",
    "href": "liens.html#installation-de-julia",
    "title": "Liens utiles",
    "section": "",
    "text": "Julia peut être installé par l’une des deux options suivantes (la seconde étant préférable car elle devrait devenir à terme la solution officielle)\n\nInstallation classique depuis le site : https://julialang.org/downloads\nInstallation par le biais de juliaup https://github.com/JuliaLang/juliaup, par exemple ici pour Windows.\nNote: sans accès au Windows Store (par exemple restrictions dues à une politique informatique d’entreprise) il est possible de trouver une solution alternative d’installation de juliaup ici qui se résume à\n\nTélécharger le fichier Julia.appinstaller\nExécuter le code suivant sous Powershell\nPS [path] Add-AppxPackage -AppInstallerFile Julia.appinstaller"
  },
  {
    "objectID": "liens.html#vidéos",
    "href": "liens.html#vidéos",
    "title": "Liens utiles",
    "section": "",
    "text": "Quelques vidéos utiles pour se familiariser avec le langage Julia\n\nIntro to Julia tutorial (version 1.0) by Jane Herriman Introduction assez complète de la syntaxe de base et quelques éléments avancés.\nThe Unreasonable Effectiveness of Multiple Dispatch Plus de détails sur un atout majeur du langage : le “multiple dispatch”."
  },
  {
    "objectID": "liens.html#bibliothèques-utiles-pour-le-cours",
    "href": "liens.html#bibliothèques-utiles-pour-le-cours",
    "title": "Liens utiles",
    "section": "",
    "text": "Documentation générale de Julia\nPlots.jl\nXsum.jl\nZygote.jl\nPolynomials.jl\nInterpolations.jl"
  },
  {
    "objectID": "notebooks/1_virgule_flottante.html",
    "href": "notebooks/1_virgule_flottante.html",
    "title": "Cours ENPC - Pratique du calcul scientifique",
    "section": "",
    "text": "Afficher les calculs de la présentation du cours 0.1 + 0.2 == 0.3 etc…\nPour afficher un résultat, plusieurs commandes sont possibles : print, println, display et @show.\nOn rappelle que l’aide sur une commande est accessible depuis le REPL en tapant d’abord ? puis la commande. Si la commande appartient à une bibliothèque non standard, il faut au préalable charger la bibliothèque par using ou import.\n\n\n\n\nConstruire une fonction renvoyant le signe, l’exposant et la mantisse en s’arrêtant à n bits après la virgule\nAppliquer à x = 1/BigFloat(10) en tronquant la mantisse à 52 bits après la virgule\nExpliquer ce que renvoie bitstring(0.1)[13:end] et la raison du 13\nComparer\n\n\n\n\n\nImplémenter l’algorithme décimal → binaire pour des entiers \\(n∈\\mathbb{N}\\)\nAppliquer à quelques entiers et vérifier le résultat avec bitstring\n\n\n\n\n\n\n\nExpliquer par analyse des exposants et mantisses pourquoi \\(0.1 \\widehat + 0.2≠0.3\\) dans Float16\n\n\n\nAfficher bitstring(1), bitstring(-1), 2^63, -2^63-1 et 2^64\n\n\n\n\nImplémenter une fonction “naïve” MySum faisant la somme des composantes d’un vecteur X\nImplémenter l’algorithme KahanSum\nChoisir un type T, un entier n et construire le vecteur\nX=[one(T),eps(T)/2,...,eps(T)/2] où eps(T)/2 est répété \\(n-1\\) fois\nComparer les sommes obtenues en utilisant les fonctions MySum, sum et KahanSum sur X ainsi que sur view(X,n:-1:1)\nConstruire un vecteur aléatoire Y=rand(T,n) ainsi qu’une version ordonnée Ỹ=sort(Y)\nComparer les sommes obtenues sur Y et Ỹ avec les différents algorithmes. On pourra notamment se servir de la bibliothèque Xsum.jl comme référence.\n\n\n\n\n\nOn pose \\(f(x)=\\exp{x}\\), \\(x_0=1\\) et \\(d(δ)=\\frac{f(x_0+δ)-f(x_0)}{δ}\\). Tracer l’erreur commise entre \\(d(δ)\\) et \\(f'(x_0)=\\exp{x_0}\\) en fonction de \\(δ ∈ [10^{-17},10^{0}]\\) sur un graphe log-log en repérant les droites verticales d’équations \\(δ=ε_M\\) et \\(δ=\\sqrt{ε_M}\\).\nRefaire la question précédente avec une fonction quelconque dont la dérivée exacte sera calculée par différentiation numérique à l’aide de la bibliothèque Zygote.jl.\n\nIndication :\nLes graphiques peuvent être tracés grâce à la bibliothèque Plots.jl\n\ndépôt GitHub\ndocumentation\ntutoriel\nIl est possible de définir des options de tracé par défaut (qui peuvent être redéfinies ponctuellement au besoin) par\nPlots.default(fontfamily=\"Computer Modern\",\n            titlefontsize=20,\n            xlabelfontsize=20,\n            ylabelfontsize=20,\n            legendfontsize=16,\n            xtickfontsize=16,\n            ytickfontsize=16,\n            linewidth=2,\n            markersize=7,\n            framestyle=:box,\n            label=nothing,\n            grid=true)"
  },
  {
    "objectID": "notebooks/1_virgule_flottante.html#calcul-en-virgule-flottante",
    "href": "notebooks/1_virgule_flottante.html#calcul-en-virgule-flottante",
    "title": "Cours ENPC - Pratique du calcul scientifique",
    "section": "",
    "text": "Afficher les calculs de la présentation du cours 0.1 + 0.2 == 0.3 etc…\nPour afficher un résultat, plusieurs commandes sont possibles : print, println, display et @show.\nOn rappelle que l’aide sur une commande est accessible depuis le REPL en tapant d’abord ? puis la commande. Si la commande appartient à une bibliothèque non standard, il faut au préalable charger la bibliothèque par using ou import.\n\n\n\n\nConstruire une fonction renvoyant le signe, l’exposant et la mantisse en s’arrêtant à n bits après la virgule\nAppliquer à x = 1/BigFloat(10) en tronquant la mantisse à 52 bits après la virgule\nExpliquer ce que renvoie bitstring(0.1)[13:end] et la raison du 13\nComparer\n\n\n\n\n\nImplémenter l’algorithme décimal → binaire pour des entiers \\(n∈\\mathbb{N}\\)\nAppliquer à quelques entiers et vérifier le résultat avec bitstring\n\n\n\n\n\n\n\nExpliquer par analyse des exposants et mantisses pourquoi \\(0.1 \\widehat + 0.2≠0.3\\) dans Float16\n\n\n\nAfficher bitstring(1), bitstring(-1), 2^63, -2^63-1 et 2^64\n\n\n\n\nImplémenter une fonction “naïve” MySum faisant la somme des composantes d’un vecteur X\nImplémenter l’algorithme KahanSum\nChoisir un type T, un entier n et construire le vecteur\nX=[one(T),eps(T)/2,...,eps(T)/2] où eps(T)/2 est répété \\(n-1\\) fois\nComparer les sommes obtenues en utilisant les fonctions MySum, sum et KahanSum sur X ainsi que sur view(X,n:-1:1)\nConstruire un vecteur aléatoire Y=rand(T,n) ainsi qu’une version ordonnée Ỹ=sort(Y)\nComparer les sommes obtenues sur Y et Ỹ avec les différents algorithmes. On pourra notamment se servir de la bibliothèque Xsum.jl comme référence.\n\n\n\n\n\nOn pose \\(f(x)=\\exp{x}\\), \\(x_0=1\\) et \\(d(δ)=\\frac{f(x_0+δ)-f(x_0)}{δ}\\). Tracer l’erreur commise entre \\(d(δ)\\) et \\(f'(x_0)=\\exp{x_0}\\) en fonction de \\(δ ∈ [10^{-17},10^{0}]\\) sur un graphe log-log en repérant les droites verticales d’équations \\(δ=ε_M\\) et \\(δ=\\sqrt{ε_M}\\).\nRefaire la question précédente avec une fonction quelconque dont la dérivée exacte sera calculée par différentiation numérique à l’aide de la bibliothèque Zygote.jl.\n\nIndication :\nLes graphiques peuvent être tracés grâce à la bibliothèque Plots.jl\n\ndépôt GitHub\ndocumentation\ntutoriel\nIl est possible de définir des options de tracé par défaut (qui peuvent être redéfinies ponctuellement au besoin) par\nPlots.default(fontfamily=\"Computer Modern\",\n            titlefontsize=20,\n            xlabelfontsize=20,\n            ylabelfontsize=20,\n            legendfontsize=16,\n            xtickfontsize=16,\n            ytickfontsize=16,\n            linewidth=2,\n            markersize=7,\n            framestyle=:box,\n            label=nothing,\n            grid=true)"
  },
  {
    "objectID": "notebooks/2_interpolation.html",
    "href": "notebooks/2_interpolation.html",
    "title": "Cours ENPC - Pratique du calcul scientifique",
    "section": "",
    "text": "Les graphiques peuvent être tracés grâce à la bibliothèque Plots.jl\n\ndépôt GitHub\ndocumentation\ntutoriel\nIl est possible de définir des options de tracé par défaut (qui peuvent être redéfinies ponctuellement au besoin) par\nPlots.default(fontfamily=\"Computer Modern\",\n            titlefontsize=20,\n            xlabelfontsize=20,\n            ylabelfontsize=20,\n            legendfontsize=16,\n            xtickfontsize=16,\n            ytickfontsize=16,\n            linewidth=2,\n            markersize=7,\n            framestyle=:box,\n            label=nothing,\n            grid=true)\n\n\n\nÉcrire un code Julia pour interpoler la fonction suivante à l’aide d’un polynôme de degré 20 sur l’intervalle \\([-1, 1]\\). \\[\n    f(x) = \\tanh\\left(\\frac{x+1/2}{\\varepsilon}\\right) + \\tanh\\left(\\frac{x}{\\varepsilon}\\right) + \\tanh\\left(\\frac{x-1/2}{\\varepsilon}\\right),\n    \\qquad \\varepsilon = .01\n\\] Utiliser des noeuds équidistants puis des noeuds de Tchebychev et comparer les deux approches en termes de précision. Tracer la fonction \\(f\\) ainsi que les polynômes d’interpolation.\nIndications :\n\nPour limiter les erreurs d’arrondi numérique, il est préférable que la fonction renvoie un type BigFloat, autrement dit\nf(x) = BigFloat(tanh((x+1/2)/ε) + tanh(x/ε) + tanh((x-1/2)/ε))\nPour calculer rapidement les noeuds de Tchebychev, on peut exploiter la macro @. (comme toujours, il est conseillé de se référer à la documentation d’une commande en tapant ? puis la commande dans la console). Cette commande évite d’utiliser des . après chaque fonction ou avant chaque opérateur.\nx = @. -cos(π*((0:n-1)+1/2)/n)\nIl peut être utile pour comparer les deux interpolations de limiter les valeurs minimale et maximale sur l’axe y à l’aide de l’option ylims = (ymin,ymax) dans une fonction de tracé plot, scatter, ou leurs équivalents terminant par !. On rappelle que, par convention en Julia (et non par obligation), une fonction dont le nom se termine par ! modifie ses arguments. Dans le cas d’un graphe, la première commande initiant le graphe ne doit pas comporter de ! (plot, scatter, …) tandis que les suivantes incrémentant le même graphe se terminent par ! (plot!, scatter!, …). Toute omission du ! est considéré comme un redémarrage à zéro du tracé.\nPour calculer la norme infinie d’une fonction afin d’évaluer la précision de l’interpolation, on pourra exploiter la fonction norm(...,Inf) de la bibliothèque LinearAlgebra avec une échantillonnage suffisamment fin des valeurs de la fonction.\n\n\n\n\n\n\n\nEn exploitant la macro @animate de la bibliothèque Plots.jl, créer une animation permettant de voir l’évolution superposée des interpolations avec noeuds équidistants et de Tchebychev de la fonction de Runge \\(u(x)=\\frac{1}{1+25x^2}\\) sur l’intervalle \\([-1,1]\\). On fera varier le nombre de noeuds par exemple de 2 à 50 et on pourra tenir compte des indications de l’exercice précédent pour limiter par exemple l’extension en y."
  },
  {
    "objectID": "notebooks/2_interpolation.html#interpolation-et-approximation",
    "href": "notebooks/2_interpolation.html#interpolation-et-approximation",
    "title": "Cours ENPC - Pratique du calcul scientifique",
    "section": "",
    "text": "Les graphiques peuvent être tracés grâce à la bibliothèque Plots.jl\n\ndépôt GitHub\ndocumentation\ntutoriel\nIl est possible de définir des options de tracé par défaut (qui peuvent être redéfinies ponctuellement au besoin) par\nPlots.default(fontfamily=\"Computer Modern\",\n            titlefontsize=20,\n            xlabelfontsize=20,\n            ylabelfontsize=20,\n            legendfontsize=16,\n            xtickfontsize=16,\n            ytickfontsize=16,\n            linewidth=2,\n            markersize=7,\n            framestyle=:box,\n            label=nothing,\n            grid=true)\n\n\n\nÉcrire un code Julia pour interpoler la fonction suivante à l’aide d’un polynôme de degré 20 sur l’intervalle \\([-1, 1]\\). \\[\n    f(x) = \\tanh\\left(\\frac{x+1/2}{\\varepsilon}\\right) + \\tanh\\left(\\frac{x}{\\varepsilon}\\right) + \\tanh\\left(\\frac{x-1/2}{\\varepsilon}\\right),\n    \\qquad \\varepsilon = .01\n\\] Utiliser des noeuds équidistants puis des noeuds de Tchebychev et comparer les deux approches en termes de précision. Tracer la fonction \\(f\\) ainsi que les polynômes d’interpolation.\nIndications :\n\nPour limiter les erreurs d’arrondi numérique, il est préférable que la fonction renvoie un type BigFloat, autrement dit\nf(x) = BigFloat(tanh((x+1/2)/ε) + tanh(x/ε) + tanh((x-1/2)/ε))\nPour calculer rapidement les noeuds de Tchebychev, on peut exploiter la macro @. (comme toujours, il est conseillé de se référer à la documentation d’une commande en tapant ? puis la commande dans la console). Cette commande évite d’utiliser des . après chaque fonction ou avant chaque opérateur.\nx = @. -cos(π*((0:n-1)+1/2)/n)\nIl peut être utile pour comparer les deux interpolations de limiter les valeurs minimale et maximale sur l’axe y à l’aide de l’option ylims = (ymin,ymax) dans une fonction de tracé plot, scatter, ou leurs équivalents terminant par !. On rappelle que, par convention en Julia (et non par obligation), une fonction dont le nom se termine par ! modifie ses arguments. Dans le cas d’un graphe, la première commande initiant le graphe ne doit pas comporter de ! (plot, scatter, …) tandis que les suivantes incrémentant le même graphe se terminent par ! (plot!, scatter!, …). Toute omission du ! est considéré comme un redémarrage à zéro du tracé.\nPour calculer la norme infinie d’une fonction afin d’évaluer la précision de l’interpolation, on pourra exploiter la fonction norm(...,Inf) de la bibliothèque LinearAlgebra avec une échantillonnage suffisamment fin des valeurs de la fonction.\n\n\n\n\n\n\n\nEn exploitant la macro @animate de la bibliothèque Plots.jl, créer une animation permettant de voir l’évolution superposée des interpolations avec noeuds équidistants et de Tchebychev de la fonction de Runge \\(u(x)=\\frac{1}{1+25x^2}\\) sur l’intervalle \\([-1,1]\\). On fera varier le nombre de noeuds par exemple de 2 à 50 et on pourra tenir compte des indications de l’exercice précédent pour limiter par exemple l’extension en y."
  },
  {
    "objectID": "notebooks.html",
    "href": "notebooks.html",
    "title": "Notebooks Jupyter",
    "section": "",
    "text": "Notebooks Jupyter\n\nTutoriels Julia par Jane Herriman\nCalcul en virgule flottante\nInterpolation"
  },
  {
    "objectID": "poly.html",
    "href": "poly.html",
    "title": "Polycopié du cours",
    "section": "",
    "text": "Polycopié du cours\n\nNotes complètes\nIntroduction\nChapter 1: Floating point arithmetic\nChapter 2: Interpolation and approximation\nChapter 3: Numerical integration\nChapter 4: Solving linear equations\nChapter 5: Solving nonlinear equations\nChapter 6: Calculating eigenvalues and eigenvectors\nChapter 7: Numerical integration of differential equations\nChapter 8: Numerical optimization\nAppendix A: Linear algebra\nAppendix B: Introduction to Julia\nAppendix C: Chebyshev polynomials\nBibliography"
  }
]